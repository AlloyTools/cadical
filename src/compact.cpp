#include "internal.hpp"
#include "external.hpp"
#include "macros.hpp"
#include "message.hpp"

namespace CaDiCaL {

/*------------------------------------------------------------------------*/

// Compactifying removes holes generated by inactive variables (fixed,
// eliminated or substituted) by mapping active variables indices down to a
// contiguous interval of indices.

/*------------------------------------------------------------------------*/

bool Internal::compactifying () {
  if (level) return false;
  if (!opts.compact) return false;
  if (stats.conflicts < lim.compact) return false;
  int inactive = max_var - active_variables ();
  assert (inactive >= 0);
  if (!inactive) return false;
  return inactive >= opts.compactlim * max_var;
}

/*------------------------------------------------------------------------*/

// Map data in old array 'NAME' to new position as given by 'map'.

#define MAP_ARRAY(TYPE,NAME) \
do { \
  TYPE * TMP = new TYPE [new_vsize]; \
  for (int SRC = 1; SRC <= max_var; SRC++) { \
    const int DST = map[SRC]; \
    if (!DST) continue; \
    TMP[DST] = NAME[SRC]; \
  } \
  memset (TMP, 0, sizeof TMP[0]); \
  delete [] NAME; \
  NAME = TMP; \
} while (0)

/*------------------------------------------------------------------------*/

// Same as 'MAP_ARRAY' but two sided (positive & negative literal).

#define MAP2_ARRAY(TYPE,NAME) \
do { \
  TYPE * TMP = new TYPE [2*new_vsize]; \
  for (int SRC = 1; SRC <= max_var; SRC++) { \
    const int DST = map[SRC]; \
    if (!DST) continue; \
    TMP[2*DST] = NAME[2*SRC]; \
    TMP[2*DST+1] = NAME[2*SRC+1]; \
  } \
  memset (TMP, 0, sizeof TMP[0]); \
  delete [] NAME; \
  NAME = TMP; \
} while (0)

/*------------------------------------------------------------------------*/

// Map a 'vector<int>' of literals, flush inactive literals, resize and
// shrink it to fit its new size after flushing.

#define MAP_AND_FLUSH_INT_VECTOR(V) \
do { \
  const const_int_iterator end = V.end (); \
  int_iterator j = V.begin (); \
  const_int_iterator i; \
  for (i = j; i != end; i++) { \
    const int SRC = *i; \
    int DST = map[abs (SRC)]; \
    if (!DST) continue; \
    if (SRC < 0) DST = -DST; \
    *j++ = DST; \
  } \
  V.resize (j - V.begin ()); \
  shrink_vector (V); \
} while (0)

/*------------------------------------------------------------------------*/

void Internal::compact () {
  START (compact);
  stats.compacts++;

  assert (!level);
  assert (!conflict);
  assert (clause.empty ());
  assert (levels.empty ());
  assert (analyzed.empty ());
  assert (minimized.empty ());
  assert (control.size () == 1);
  assert (resolved.empty ());

  // We produce a compactifying garbage collector like map of old 'src' to
  // new 'dst' variables.  Inactive variables are just skipped except for
  // fixed ones which will be mapped to the first fixed variable (in the
  // appropriate phase).  This avoids to handle the case 'fixed value'
  // seperately as it is done in Lingeling, where fixed variables are
  // mapped to the internal variable '1'.
  //
  int * map, dst = 0, first_fixed = 0;
  NEW (map, int, max_var + 1);
  map[0] = 0;
  for (int src = 1; src <= max_var; src++) {
    const Flags & f = flags (src);
    if (f.active ()) map[src] = ++dst;
    else if (!f.fixed () || first_fixed) map[src] = 0;
    else map[first_fixed = src] = ++dst;
  }

  if (first_fixed) LOG ("found first fixed %d", first_fixed);
  else LOG ("no variable fixed");

  const int new_max_var = dst;
  const size_t new_vsize = dst + 1;	// Adjust to fit 'new_max_var'.

  /*----------------------------------------------------------------------*/
  // In this first part we only map stuff without reallocation.
  /*----------------------------------------------------------------------*/

  // Flush the external indices.  This has to occur before we map 'vals'.
  {
    const int first_fixed_val = first_fixed ? val (first_fixed) : 0;
    for (int eidx = 1; eidx <= external->max_var; eidx++) {
      const int src = external->e2i[eidx];
      if (!src) dst = 0;
      else {
	dst = map[abs (src)];
	if (src < 0) dst = -dst;
	const int tmp = val (src);
	if (tmp) {
	  assert (first_fixed_val);
	  dst = map[first_fixed];
	  if (tmp != first_fixed_val) dst = -dst;
	}
      }
      LOG ("compact %ld maps external %d to internal %d",
        stats.compacts, eidx, dst);
      external->e2i[eidx] = dst;
    }
  }

  // Map the literals in all clauses.
  {
    const const_clause_iterator end = clauses.end ();
    const_clause_iterator i;
    for (i = clauses.begin (); i != end; i++) {
      Clause * c = *i;
      assert (!c->garbage);
      const const_literal_iterator eoc = c->end ();
      literal_iterator j;
      for (j = c->begin (); j != eoc; j++) {
	const int lit = *j;
	assert (active (lit));
	int dst = map[abs (lit)];
	if (lit < 0) dst = -dst;
	assert (dst);
	*j = dst;
      }
    }
  }

  // Map the blocking literals in all watches.
  //
  if (watches ()) {
    for (int idx = 1; idx <= max_var; idx++) {
      for (int sign = -1; sign <= 1; sign += 2) {
	const int lit = sign*idx;
	Watches & ws = watches (lit);
	assert (active (lit) || ws.empty ());
	const const_watch_iterator end = ws.end ();
	watch_iterator i;
	for (i = ws.begin (); i != end; i++) {
	  const int blit = i->blit;
	  assert (active (blit));
	  int dst = map[abs (blit)];
	  if (blit < 0) dst = -dst;
	  assert (dst);
	  i->blit = dst;
	}
      }
    }
  }

  // We first flush inactive variables and map the links in the queue.  This
  // has to be done before we map the actual links data structure 'ltab'.
  {
    int prev = 0, mapped_prev = 0, next;
    for (int idx = queue.first; idx; idx = next) {
      Link * l = ltab + idx;
      next = l->next;
      if (idx == first_fixed) continue;
      const int dst = map[idx];
      if (!dst) continue;
      assert (active (idx));
      if (prev) ltab[prev].next = dst; else queue.first = dst;
      l->prev = mapped_prev;
      mapped_prev = dst;
      prev = idx;
    }
    if (prev) ltab[prev].next = 0; else queue.first = 0;
    queue.unassigned = queue.last = mapped_prev;
  }

  /*----------------------------------------------------------------------*/
  // In this second part we not only map stuff but also reallocate memory.
  /*----------------------------------------------------------------------*/

  // Now we continue in reverse order of allocated bytes, e.g., see
  // 'Internal::enlarge' which reallocates in order of allocated bytes.

  MAP_ARRAY (Flags, ftab);
  MAP_ARRAY (signed char, marks);
  MAP_ARRAY (signed char, phases);

  // Special case for 'val' as always since for 'val' we trade branch less
  // code for memory and always allocated an [-maxvar,...,maxvar] array.
  {
    signed char * new_vals = new signed char [2*new_vsize];
    new_vals += new_vsize;
    for (int src = -max_var; src <= -1; src++)
      new_vals[-map[-src]] = vals[src];
    for (int src = 1; src <= max_var; src++)
      new_vals[map[src]] = vals[src];
    new_vals[0] = 0;
    vals -= vsize;
    delete [] vals;
    vals = new_vals;
  }

  MAP_ARRAY (int, i2e);
  MAP2_ARRAY (int, ptab);
  MAP_ARRAY (long, btab);
  if (ntab2) MAP_ARRAY (long, ntab2);
  MAP_ARRAY (Link, ltab);
  MAP_ARRAY (Var, vtab);
  if (ntab) MAP2_ARRAY (long, ntab);
  if (wtab) MAP2_ARRAY (Watches, wtab);
  if (otab) MAP2_ARRAY (Occs, otab);
  if (big) MAP2_ARRAY (Bins, big);

  assert (propagated == trail.size ());
  MAP_AND_FLUSH_INT_VECTOR (trail);
  propagated = trail.size ();

  if (!probes.empty ()) MAP_AND_FLUSH_INT_VECTOR (probes);

  // The simplest way to map the elimination schedule is to get all elements
  // from the heap and reinsert them.  This could be slightly improved in
  // terms of speed if we add a 'flush (int * map)' function to 'Heap', but
  // is pretty complicated and would require that the 'Heap' knows that
  // mapped elements with 'zero' destination should be flushed.  Note that
  // we use stable heap sorting.
  //
  if (!esched.empty ()) {
    vector<int> saved;
    while (!esched.empty ()) {
      const int src = esched.front ();
      esched.pop_front ();
      const int dst = map [src];
      if (dst && src != first_fixed) saved.push_back (dst);
    }
    esched.clear ();
    const const_int_iterator end = saved.end ();
    const_int_iterator i;
    for (i = saved.begin (); i != end; i++)
      esched.push_back (*i);
    esched.shrink ();
  }

  /*----------------------------------------------------------------------*/

  DEL (map, int, max_var);

  VRB ("compact", stats.compacts,
    "reducing internal variables from %d to %d",
    max_var, new_max_var);

  max_var = new_max_var;
  vsize = new_vsize;

  stats.now.fixed = first_fixed ? 1 : 0;
  stats.now.substituted = stats.now.eliminated = 0;

  inc.compact += opts.compactint;
  lim.compact = stats.conflicts + inc.compact;
  report ('c');
  STOP (compact);
}

};
